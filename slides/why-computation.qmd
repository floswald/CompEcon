---
title: Why Do We Care about Computation?
subtitle: We're economists in the end, no?
format:
  revealjs:
    theme: _extensions/clean/clean.scss
    self-contained: true
author:
  - name: Florian Oswald
    url: https://floswald.github.io
    email: florian.oswald@unito.it
    orcid: 0000-0001-7737-2038
    affiliations:
      - University of Turin
      - Collegio Carlo Alberto
      - JPE Data Editor
date: last-modified
execute: 
  cache: true
---


## Today's Agenda

1. Logistics.

::: {.fragment}
2. Why Economists Must Talk About Computing.
:::

::: {.fragment}
3. How to Choose a Programming Language.
:::

## Who Am I?

::: {.columns}
::: {.column width="50%"}
![](https://media.giphy.com/media/Q7LP0tm86sBWIqjFCL/giphy.gif){fig-align="center" width="60%"}
:::

::: {.column width="50%"}
::: {.fragment}

- Associate Prof at ESOMAS Unito

- Urban, Macro, IO, Computation

- Experience with HPC systems, AWS and google cloud

- Research projects in `fortran`, `C++`,  `R`, `julia`, `python` and `PostgreSQL`

- I am the JPE Data Editor.
:::
:::
:::


## Logistics and Course Structure

* Meetings: Every Monday and Tuesday

::: {.fragment}
* Communication: Slack
:::

::: {.fragment}
* Materials: All online via [course website](https://floswald.github.io/CompEcon)
:::

::: {.fragment}
* Grades: 60% homeworks, 40% term project
    * You should do all homeworks in teams of 2 or 3.
    * Term project in teams of 2.
:::

::: {.fragment}
* Term Project: Replicate a published paper with computational content.
    * More info [on syllabus](https://floswald.github.io/CompEcon/#term_project)
    * Deadline for hand in: end of term.
:::



## Economists and Computation I

::: {.callout-note}
This part borrows heavily from [Jesus Fernandez-Villaverde's lectures. Thanks Jesus!](https://www.sas.upenn.edu/~jesusfv/teaching.html)
:::

Computation has become an important tool in Economics: 

1. Macro: Solution of DSGE models, forecasting models, ...
2. Micro: Agent-based models, games, life-cycle models, high-dimensional fixed effects models ...
3. Econometrics: Simulation-based estimators and large datasets, ...
4. Trade and spatial economics: multi-country-firm-type models, with dynamics, ...
5. Finance: Asset Pricing, Value at Risk models, ...

## Economists and Computation II

* [Ken Judd](https://web.stanford.edu/~judd/): Computation often *complements*, rather than substitutes, theory. 
> If theory shows that some partial derivative of interest is *positive*, computation can tell us *how positive*.

::: {.columns}
::: {.column}

::: {.fragment}
* Economics is not different from many other fields. 
    - Computational Biology (e.g. `R` Bioconductor)
    - Computational Chemistry
    - Physics, Engineering, Applied Maths
    - Comparative Literature
    - Astronomy
:::
:::

::: {.column}

::: {.fragment}
* [Research is now fundamentally connected to software](https://www.nature.com/articles/d41586-021-00075-2)
:::
:::
:::



## What Does This Mean for You?

1. You (will) spend a considerable amount of your time writing code.

::: {.fragment}
2. You (will) collaborate with coauthors and colleagues on code.
:::

::: {.fragment}
3. You (will) read and evaluate papers that use computational methods.
:::

::: {.fragment}
4. (Hopefully you will be supplied with the paper's code for your evaluation.)
:::

::: {.fragment}
5. For all practical purposes, **you are a research software engineer**. üë∑‚Äç‚ôÄÔ∏è üë∑üèΩ‚Äç‚ôÇÔ∏è Carefully choose the best methods for software engineering at any time. 
:::


## A Brief History of Computing in Economics

::: {.incremental}

1. 1800-1960: Economics is about intuition. And maths. Computation done by hand.
2. 1960
3. *Software just happens* (We'll hire an RA to write the code.)  
4. 2010-2025: *The vast majority of research software is single use and poor quality*. We have 19 (!) econ journals signed up to the [Data and Code Availability Standard (DCAS)](https://datacodestandard.org)
5. 2026- *That's you guys!* üí™
:::




## Gentzkow and Shapiro

>Here is a good rule of thumb: If you are trying to solve a problem, and there are multi-billion dollar firms whose entire business model depends on solving the same problem, and there are whole courses at your university devoted to how to solve that problem, you might want to figure out what the experts do and see if you can't learn something from it.

* [Gentzkow and Shapiro: Code and Data](https://web.stanford.edu/%7Egentzkow/research/CodeAndData.pdf)
* [GSLab-econ](https://github.com/gslab-econ)
* [RA-manual](https://github.com/gslab-econ/ra-manual/wiki)
* Whatever you do: don't reinvent the wheel. ‚ò∏Ô∏è

* [A Gentle Introduction to Effective Computing in Quantitative Research](https://mitpress.mit.edu/books/gentle-introduction-effective-computing-quantitative-research)

## Aim of This Course {background-image="images/fortranmanual.png" background-size="500px 300px" background-position="85% 25%"}

* Take the *fear* out of computation.

<br>
<br>
<br>
<br>
<br>

::: {.fragment}
* Provide you with a set of tools based on which you can learn to tackle frontier computational problems.
:::

::: {.fragment}
* Teach you some best practices from Open Source Software (OSS)
:::

::: {.fragment}
* Have some fun! üéâ
:::

## Programming Languages {.impact}

### How To Choose?

## Choosing a Language

* You are an economics grad student and need to choose your *weapon of choice*.

::: {.fragment}
* You will use more than one language. (This is a good thing.)
:::

::: {.fragment}
* All Languages have pros and cons. I will give some opinionated advice.
:::

::: {.fragment}
* Then I will force you to use a certain language to complete homeworks üòú
:::

## Taxonomy of Languages

![](images/stack.png){fig-align="center" width="95%"}

## The Pros/Cons Rundown {.impact}

## Hello, World?

::: {.fragment}
* It's good custom to first print `hello world` when introducing a language. It's fun, but pretty uninformative. Like, *what's the performance of printing "hello, world"?*
:::

::: {.fragment}
* Instead, we will show in each language how to implement the function `sum over an array` of values `a`:
    $$\text{sum}(a) = \sum_{i=1}^n a_i$$
    where $n$ is the number of elements in $a$

* Later, we will then *benchmark* each language to see tradeoff between high- and low level languages.
:::

## `C/C++`

* The world pretty much runs on `C++`.

::: {.fragment}
* If you now some `C++` and some `Unix` you know a lot already.
:::

::: {.fragment}
* Developed at Bell Labs in 1980s.
:::

::: {.fragment}
* All `C` programs are valid `C++`, not other way around.
:::

## C++ Code Example

```C
//sumvec.cpp
#include <iostream>
#include <vector>
int main(){
    std::vector<int> x;
    for (int i=1;i<5;i++){
        x.push_back(i);
    }
    int sum = 0;
    for (std::vector<int>::iterator i=x.begin();i!=x.end();i++){
        sum += *i;
    }
    std::cout << "sum is " << sum << std::endl;
}
//compile
g++ sumvec.cpp -o sum.x
```

## `C sum`

* Defining the function:
    ```C
    #include <stddef.h>
    double c_sum(size_t n, double *X) {
        double s = 0.0;
        for (size_t i = 0; i < n; ++i) {
            s += X[i];
        }
        return s;
    }
    ```
* place in `main()`, compile and run as above.

## `C++`: Pros and Cons

::: {.columns}
::: {.column width="50%"}
### Pros
* Very versatile.
* Continuously Evolving. C++ 2020 standard is current.
* Very performant.
* Excellent open source compilers.
* Very stable and widely used.
* Large community.
:::

::: {.column width="50%"}
::: {.fragment}
### Cons
* Hard to learn. Pointers, Classes, OOP in general.
* Some find it hard to work with Compiled languages.
* It's easy to overcomplicate things for novices.
:::
:::
:::

## Python

* *The* general purpose language out there. Swiss Army Knife. All Terrain. üöô

::: {.fragment}
* Open Source
:::

::: {.fragment}
* Designed by Guido von Rossum.
:::

::: {.fragment}
* Elegant, intuitive, full OOP support (Classes etc).
:::

## `python sum`

* we just use the built-in `sum`:
    ```python
    a = [1,2,3,4,5]
    sum(a)
    ```
* that's it!

## Python Pros/Cons

::: {.columns}
::: {.column width="50%"}
### Pros
* Console: good for exploration.
* Many useful libraries (NumPy, SciPy, Pandas, matplotlib)
* Easy Unit Testing
* Very Performant String Manipulation
* Large community
:::

::: {.column width="50%"}
::: {.fragment}
### Cons
* Slow.
* Version `2.7` or `3.6`? Huge problem.
* High performance routes use annoted Python code. Numba: JIT compiler,Pypy: JIT compiler, Cython: compile to C++
* All feel a bit like a [78-liter 3,500hp V18 truck engine on a Mini Chassis](https://www.hotcars.com/21-pictures-of-small-cars-with-big-modded-engines/).
:::
:::
:::

## Python Performance Analogy

![](images/mini.jpg){width="80%"}

## `R`

* High level open source language for statistical computing. 

::: {.fragment}
* Ross Ihaka and Robert Gentleman developed `R` as a successor to John Chambers' `S`
:::

::: {.fragment}
* `R` went open source quickly via [http://cran.r-project.org/](http://cran.r-project.org/)
:::

::: {.fragment}
* Tremendously rich add-on packages environment.
:::

::: {.fragment}
* Has basic OOP support via `S4` classes and methods.
:::

## `R sum`

* we just use the built-in `sum`:
    ```R
    a = 1:5
    sum(a)
    ```
* that's (again) it!

## `R` Pros/Cons

::: {.columns}
::: {.column width="50%"}
### Pros
* Excellent IDE [Rstudio](https://rstudio.com)
* Thousands of high quality packages. `tidyverse` is a sensation in itself.
* *Many many* [econometrics-related packages](https://cran.r-project.org/web/views/Econometrics.html).
* Wide community.
* `Rcpp` is good to connect to `C++`
* Unbeatable for **spatial data**: the `sf` package.
* Very good for data processing.
:::

::: {.column width="50%"}
::: {.fragment}
### Cons
* Base `R` is slow.
* Not a modern language. Some quite arcane behaviours.
* `Rcpp` means you end up writing `C++` code.
* Not straightforward to write performant low-level code close to the math (i.e.: loops)
:::
:::
:::

## Fortran

* The Grandfather of all languages üë¥üèΩ

::: {.fragment}
* FORTRAN (Formula Translation) was developed in 1957.
:::

::: {.fragment}
* Still used by many economists, for example [Mitman-Kaplan-Violante JPE 2020](https://github.com/kurtmitman/housing-boom-bust)
:::

::: {.fragment}
* Still used for many scientific problems (nuclear bombs design, wheather forecasts, phyical experiments, etc) üí£ üå¶
:::

## Fortran Example

* create a text file `test.f90`:
    ```fortran
    program sumit
        implicit none
        double precision a(5)   ! allocate an array with 5 slots
        a = (/1,2,3,4,5/)       ! fill with values
        print *,"result is ", sum(a)
    end program sumit
    ```

* compile it and run it:
    ```bash
    $ gfortran test.f90 -o test
    $ ./test
     result is    15.000000000000000  
    ```

## `FORTRAN` Pros/Cons

::: {.columns}
::: {.column width="50%"}
### Pros
* Relatively easy to learn.
* Good array support built in.
* Good parallelization support via MPI.
* Fast.
:::

::: {.column width="50%"}
::: {.fragment}
### Cons
* Different compilers implement different standards (Intel Fortran vs `GFORTRAN` array constructor, e.g.)
* Small user community.
* Not very many tutorials.
* Not faster than C++ (used to be true).
* Hard to automatize unit testing via e.g. [pfunit](http://pfunit.sourceforge.net).
* Language is very bare-bone. 
* Hard to process data.
:::
:::
:::

## Victims of Speed vs Productivity Tradeoff?

* We have seen high-level langs (R, python etc) are good for productivity: Iterate fast on `try, fail, repeat`

::: {.fragment}
* We have seen that low level languages *run* fast, but are worse for productivity.
:::

::: {.fragment}
* So we cannot have both speed and productivity. 
:::

::: {.fragment}
* Or can we?
:::

## Can We Have Both? {.impact background-image="images/obama-yes.jpg"}

## Case Study {.impact}

### üî•üî• Our Time is Running Out üî•üî•

#### Oswald (QE 2019)

## Homeownership and Location Choice

::: {.columns}
::: {.column width="66.7%"}
![](images/QE.png){fig-align="left" width="100%"}
:::

::: {.column width="33.3%"}
* I wanted to compute this model of housing and location choice on US micro data.

* Large state space. üö´ `R`, üö´ `python`

* Non-trivial estimation exercise.

* I had no code to build upon. And only a vague idea of how to do this.
:::
:::

## When the Clock is Ticking ‚è∞

::: {.columns}
::: {.column width="66.7%"}
![](images/fast.png){fig-align="left" width="70%"}
:::

::: {.column width="33.3%"}
* [repo](https://github.com/floswald/migration) starts with C++ (Blitz++)

* Given my C++ level, this was taking too much time to develop!

* No chance to finish in time. üòü
:::
:::

## When the Clock is Ticking ‚è∞

::: {.columns}
::: {.column width="66.7%"}
![](images/fast2.png){fig-align="left" width="70%"}
:::

::: {.column width="33.3%"}
* [repo](https://github.com/floswald/migration) starts with C++ (Blitz++)

* Given my C++ level, this was taking too much time to develop!

* No chance to finish in time. üòü

* Enter `julia`! üöÄ
:::
:::

## [Why We Created Julia](https://julialang.org/blog/2012/02/why-we-created-julia)

>We are power Matlab users. Some of us are Lisp hackers. Some are Pythonistas, others Rubyists, still others Perl hackers. There are those of us who used Mathematica before we could grow facial hair. There are those who still can't grow facial hair. We've generated more R plots than any sane person should. C is our desert island programming language. 

>We are greedy: we want more.  

>We want a language that's open source, with a liberal license. We want the speed of C with the dynamism of Ruby. We want a language that's homoiconic, with true macros like Lisp, but with obvious, familiar mathematical notation like Matlab. We want something as usable for general programming as Python, as easy for statistics as R, as natural for string processing as Perl, as powerful for linear algebra as Matlab, as good at gluing programs together as the shell. Something that is dirt simple to learn, yet keeps the most serious hackers happy. We want it interactive and we want it compiled.

## Julia History of Success

::: {.columns}
::: {.column width="50%"}
* Their proposal *was* very bold. 

* [TIOBE index](https://www.tiobe.com/tiobe-index/) 
>"The top candidate [to break into the top 20 in 2021] is without doubt Julia, which jumped from position 47 to position 23 in the last 12 months." Among languages developed on GitHub, Julia ranks #7 in stars and #9 in forks. Julia also ranks #24 in the PYPL Index and #19 in the IEEE Spectrum ranking.
:::

::: {.column width="50%"}
![](images/julia-progress.png)
:::
:::

## Julia

* Modern language

::: {.fragment}
* Built for high performance and parallel: LLVM-JIT
:::

::: {.fragment}
* Dynamically typed: good interactive use
:::

::: {.fragment}
* Rich data type system
:::

::: {.fragment}
* Many Packages.
:::

::: {.fragment}
* Good Interoperability with other languages.
:::

## [Benchmarks](https://julialang.org/benchmarks/) {background-image="images/benchmarks.png" class="full"}

## Which problem does Julia want to solve?

* Julia cofounder Stefan Karpinski [talks about **the 2 languages problem**](https://youtu.be/QTbPtKxDquc?si=2RgbDGcvtA5yv5WP)

::: {.fragment}
* **Key: Wall in scientific software stack creates a social barrier.** Developer and User are different people. (Basically: who knows C++/fortran?)
:::

![](images/stack.png){fig-align="center" width="65%"}

## Scientific Software Stacks

::: {.columns}
::: {.column width="50%"}
### Past: At least 4 langs!
* Process messy data. String manipulation, plotting, data wrangling. `R` or `python`.
* Prototype a numerical model. `matlab`
* Work around speed bottlneck: rewrite (parts) in `C++`
* Try to test (combo of `googletest` and `R`/`python`)
* Analyse output data:  `R` or `python`
* Tie it all together with `bash` scripts or `ruby` etc.
:::

::: {.column width="50%"}
::: {.fragment}
### Present: one lang only.
* Process messy data. String manipulation, plotting, data wrangling. `julia`.
* Prototype a numerical model. `julia`
* Work around speed bottlneck: rewrite (parts) in `julia`
* Test : `julia`
* Analyse output data:  `julia`
* Tie it all together with `julia`.
:::
:::
:::

## Comparing Programming Languages in Economics 

* S. Boragoan Aruoba and Jesus Fernandez-Villaverde [compare performance of languages on an Industry Standard Growth Model](https://www.sas.upenn.edu/~jesusfv/comparison_languages.pdf).

::: {.fragment}
* Conceptually difficult to write *identical* code in different languages. [Authors do a good job](https://github.com/jesusfv/Comparison-Programming-Languages-Economics). .small[(How many *tricks* is one allowed to use before an implementation is no longer comparable? Wouldn't users use all available tricks?)]
:::

::: {.fragment}
* I'll show you the results from an [updated version of the paper](https://www.sas.upenn.edu/~jesusfv/Update_March_23_2018.pdf)
:::

## Results

::: {.columns}
::: {.column width="50%"}
![](images/jesus-bench.png){fig-align="center" width="85%"}
:::

::: {.column width="50%"}
![](images/jesus-bench2.png){fig-align="center" width="85%"}
:::
:::

## Not Mentioned

There are many other languages out there. We have not mentioned

* Matlab: widely used in economics, but clearly inferior to julia (Expensive + license block)
* Stata: very popular in microeconometrics, old design, commercial software.
* Java
* Rust
* Scala
* Go

## Jaw-Droppers {.impact}

### What's so cool about base julia

## Built-in Parallelism 1: BIG DATA

::: {.columns}
::: {.column width="50%"}
## Got Some Big Data, yeah?

* Suppose you have this file on your laptop. 16GB RAM.

* Suppose you don't want to set up on a huge cluster to do you work.

* you just want to compute 1 mean from that data. How hard can it be?
:::

::: {.column width="50%"}
![](images/hugefile.png){fig-align="center" width="95%"}
:::
:::

## What `R` you going to do?

::: {.columns}
::: {.column width="66.7%"}
## Well, `R` of course.

* Come here, my old friend.

* Let's see if we can read that.

```R
> x = readBin("hugefile.bin",numeric(),"rb")
Error in readBin("hugefile.bin", numeric(), "rb") : 
  vector size cannot be NA/NaN
```
:::

::: {.column width="33.3%"}
* Oops.

* I only have 16GB of memory, so fully allocating that array to read data into it will not work on *any* language that can only do in-core computation.

* (There are *packages* for out-of-core compute)
:::
:::

## What is Julia going to do?

```julia
julia> using SharedArrays  # part of base julia

julia> @time s = SharedArray{Float64}("/Users/74097/hugefile.bin",
                 (2*10^9,));
  0.982039 seconds (235.33 k allocations: 12.553 MiB)

julia> typeof(s)    # backed by hard disk, not RAM!
SharedArray{Float64,1}

julia> size(s)  # 20 billion numbers, alright!
(2000000000,)
```

## Can julia do computation on that thing?

::: {.columns}
::: {.column width="50%"}
```julia
julia> using Statistics

julia> @time mean(s);
 12.155071 seconds (701.64 k allocations: 33.882 MiB, 0.05% gc time)
 ```
:::

::: {.column width="50%"}
* You have full **out-of-core** compute built-into julia.

* We only had to give a *filename* to the `SharedArray` constructor.

* Better than renting a data centre, no?
:::
:::

## Parallel Computation Out-of-the-box

::: {.columns}
::: {.column width="33.3%"}
## Some Boostrapping

* Great for parallel - fully independent tasks

* problem: each process needs their own copy of the data (think base R)

* See if we can do better?
:::

::: {.column width="66.7%"}
```julia
> julia -p auto
julia> nworkers()
8

julia> using SharedArrays

julia> s = SharedArray{Float64}((10^5,)); 

julia> s .= rand(10^5);
```
:::
:::

## Parallel Computation Out-of-the-box

```julia
julia> using Statistics

julia> @everywhere f(x) = [mean(rand(x, length(x))) for i in 1:1000]

julia> function f_1core(x)
            var(vcat([f(x) for i in 1:8]...))
       end

julia> function f_8core(x)
       promise = [@spawn f(x) for i in 1:8]
            var(vcat([fetch(pr) for pr in promise]...))
       end
```

## Parallel Computation Out-of-the-box

```julia
julia> @time f_1core(s)
 11.573436 seconds (811.49 k allocations: 6.003 GiB, 3.56% gc time)

julia> @time f_1core(s)
 10.708183 seconds (16.01 k allocations: 5.961 GiB, 3.10% gc time)

julia> @everywhere using Statistics

julia> @time f_8core(s)
  2.933473 seconds (67.26 k allocations: 3.703 MiB)
8.250326613582839e-7

julia> @time f_8core(s)
  2.363975 seconds (1.32 k allocations: 189.859 KiB)
8.232650394948932e-7
```

## So What?

* This is _cool_ because it is part of the core language. Not an add-on package.

* This means that contributed add-on packages can lean really hard on that infrastructure and build upon it.

* That's one of the things I really like about this language.

## Final (Opinionated) Advice

::: {.fragment}
* It's a good idea to learn a bit of `C++`. Much is based upon it, so you will see things differently. Don't overinvest (do some quick tutorials).
:::

::: {.fragment}
* Avoid learning `FORTRAN` unless you need to use legacy code.
:::

::: {.fragment}
* Learn `julia` and `R`.
:::

::: {.fragment}
* Stata is dominated by `R`.
::: -->
